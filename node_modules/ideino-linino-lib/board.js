/***
 * file: board.js
 * version: 0.6.0
 * author: https://github.com/quasto
  ***/

/*** import ***/
var	//layouts = require('./utils/layout'),
	//registers = require('./utils/register'),
	utils = require('./utils/utils'),
	path = require('path');
	_ = require('underscore'),
	S = require('string'),
	fs = require('fs'),
	exec = require('child_process').exec,
	clone = require('clone'),
	Args  = require('args-js'),
	Gpio = require('./lib/gpio').Gpio,
	Adc = require('./lib/adc').Adc,
	Pwm = require('./lib/pwm').Pwm,
	Servo = require('./lib/servo').Servo,
	StringDecoder = require('string_decoder').StringDecoder,
	decoder = new StringDecoder('utf8'),
	async = require('async');
	
var	logger,	//winston logger
	pin_layout,
	pin_register,
	pin_timer;

/***
pin_register = { 
			"A0"	:	
			{
				"DEF"	: "A0",
				"TYP"	: "analog",
				"NUM"	: "139",
				"MAP"	: "A0",
				"PIN"	: [Object Adc]
				
			},
			...
			"D2"	:	
			{
				"DEF"	: "D2",
				"TYP"	: "digital",
				"NUM"	: "117",
				"MAP"	: "SDA",
				"MOD"	: "input","output",
				"PIN"	: [Object Gpio]
			},...
			"P11" :
			{
				"DEF"	: "P11",
				"TYP"	: "pwm",
				"NUM"	: "117",
				"MAP"	: "D11",
				"PIN"	: [Object Pwm]
			}
***/

	
/*** constants ***/	
var	CHECK_MSG = {	PIN_UNDEFINED : 	"The specified pin is undefined!",
					PIN_NOT_DIGITAL: 	"The specified pin [{0}] is not a Digital pin",
					PIN_NOT_ANALOG: 	"The specified pin [{0}] is not an Analog pin",
					PIN_NOT_VIRTUAL: 	"The specified pin [{0}] is not a Virtual pin",
					PIN_NOT_LAYOUT:		"The specified pin [{0}] is not defined in the board layout!",
					PIN_NOT_DEFINED:	"The specified pin [{0}] is not already defined! You must first, call pinMode!",
					MODE_NOT_VALID: 	"The specified mode [{0}] for pin [{1}] is not valid.",
					MODE_UNDEFINED : 	"The specified mode for pin [{0}] is undefined!"
				};
				
module.exports = Board;

/*** constructor ***/
function Board(options) {
			
			this.args_options = options || {};
			/*** Board attributes ***/
			//Board.prototype.pin = layout;
			Board.prototype.model = getBoardModel();// name of board model: Arduino Yun, Linino One etc... 
			
///////////////////TEST	1		
//load the default options from config file
this.options = require('./config');			
this.options.layout = S(this.model.toLowerCase()).underscore().s; //name of board layout: arduino_yun, linino_one etc...
			
utils.mergeRecursive(this.options,this.args_options);			


//logger
logger = utils.getLogger(this.options.logger);
logger.debug(this.options);
Board.prototype.logger = logger;

//pin-layout
pin_layout = require('./utils/layouts/'+ this.options.layout).layout;			
//global var layout (forse non serve più perchè la sorgente è flr che vado a mettere Board.proto...pin -> this.pin
//layout = flr.layout;//layouts[this.options.layout];
if(typeof(pin_layout) == 'undefined' ){ 
		logger.error("Not Recognized Board Model Layout: " + this.model);
		process.exit(1);
}			
Board.prototype.pin = pin_layout;




//////////////////TEST	1		
			
			Board.prototype.LOW = utils.LOW;
			Board.prototype.HIGH = utils.HIGH;
			Board.prototype.MODES = utils.MODES; 
}

/*** PUBLIC ***/  
/*** Board functions ***/
Board.prototype.connect = function(callback){
	//
	var that = this;

//////////////////TEST 1
logger.info("Connecting to the Board "+ this.model +"...");
//pin-register
pin_register = require('./utils/layouts/'+ this.options.layout).register;//registers[this.options.layout];//
pin_timer = require('./utils/layouts/'+ this.options.layout).timer;//registers[this.options.layout];//
if(typeof(pin_register) == 'undefined' ){
	logger.error("Not Recognized Board Model: " + this.model);
	process.exit(1);
}


	
//////////////////TEST 1

/////////////////////COMMENTO PER TEST 1
/*	
	//load the default options from config file
	this.options = require('./config');
	this.options.layout = S(that.model.toLowerCase()).underscore().s;
	utils.mergeRecursive(this.options,this.args_options);
	//setting the logger;
	logger = utils.getLogger(this.options.logger);
	logger.debug(this.options);
	logger.info("Connecting to the Board "+ this.model +"...");
	Board.prototype.logger = logger;
	
	//load pin layout and register
	var flr = require('./utils/layouts/'+ this.options.layout);  
	layout = flr.layout;//layouts[this.options.layout];//
	register = flr.register;//registers[this.options.layout];//
	
	if(typeof(layout) == 'undefined' || typeof(register) == 'undefined' ){
		logger.error("Not Recognized Board Model: " + this.model);
		process.exit(1);
	}
	
	Board.prototype.pin = layout;
*/	
/////////////////////COMMENTO PER TEST 1
	
	
	
	
	//disable/unexport pwm, beacouse if were enabled in a prevoius execution, they can no longer used as digital (gpio)
	var pin_pwm = _.filter(pin_register, function(pin){ return pin.TYP == 'pwm'});
	async.each(pin_pwm, function(value,cbk){
			if( fs.existsSync('/sys/class/pwm/pwmchip0/'+value.MAP) ){
					fs.writeFileSync('/sys/class/pwm/pwmchip0/'+value.MAP+'/enable', '0');
					//fs.writeFileSync('/sys/class/mcuio_pwm/'+value.MAP+'/value', '0');
			}
			cbk();
		},function(err){
			if(err) {
				logger.error("Error during pwm reset: "+  err.message);
			} else {
				logger.debug("Linino.io pwm reset completed.");
				that.blink(50, 1500,'D13',true);
				setInterval(function(){},60 * 1000)
				logger.info("Board Connection Success.");
				callback();
			}
		});

}

function getBoardModel(){
	// Run the command in a subshell
	exec("awk '/machine/ {print $3,$4}' /proc/cpuinfo" + " 2>&1 1>output && echo done! > done");
	// Block the event loop until the command has executed.
	while (!fs.existsSync('done')) {
	// Do nothing
	}		 
	// Read the output
	var output = decoder.write( fs.readFileSync('output') );
	 
	// Delete temporary files.
	fs.unlinkSync('output');
	fs.unlinkSync('done');
	 
	return S(output).trim().s;	
}

Board.prototype.blink = function(){
	var args = Args([
			{ delay:   	Args.INT 		| Args.Required },
			{ duration:	Args.INT 		| Args.Required },
			{ led: 		Args.STRING 	| Args.Optional, _default : 'D13' }/*,
			{ release: 	Args.BOOL	 	| Args.Optional, _default : false }*/
		], arguments);

	var that = this;
	this.pinMode(args.led, utils.MODES.OUTPUT);
	
	var t = utils.LOW,
	interval = setInterval( function(){
		that.digitalWrite(args.led, t);
		t = t == utils.LOW ? utils.HIGH : utils.LOW;
	}, args.delay);
	
	setTimeout(function(){
		clearInterval(interval);
		that.digitalWrite(args.led, utils.LOW);
		/*if(args.release){
			register[args.led].PIN.unexport(function(){
				delete register[args.led].PIN;
			});
		}*/
	},args.duration);
	
}

Board.prototype.pinMode = function() {
	try {
		var args = Args([
			{pin: 		Args.STRING | Args.Required },
			{mode:		Args.STRING | Args.Required },
			{pullup:	Args.BOOL 	| Args.Optional, _default : false },
		], arguments);
	
	
		checkPinMode(args.pin, args.mode, function(err){
			if(err){
				throw err;
			}
			else{
				switch(args.mode.toLowerCase()) {
					//INPUT (DIGITAL)
					case 'input':
						if(args.pullup){//PULL-UP ENABLED
							pin_register[args.pin].PIN = new Gpio(pin_register[args.pin],'out','both');
							pin_register[args.pin].PIN.writeSync(1);
							pin_register[args.pin].PIN.setDirection('in');
							pin_register[args.pin].MOD = args.mode;
						}
						else{//PULL-UP DISABLED : default
							pin_register[args.pin].PIN = new Gpio(pin_register[args.pin],'in','both');
							pin_register[args.pin].MOD = args.mode;
						}
						break;
					//OUTPUT (DIGITAL)
					case 'output':
						pin_register[args.pin].PIN = new Gpio(pin_register[args.pin],'out','both');
						pin_register[args.pin].MOD = args.mode;
						break;
					//PWM
					case 'pwm':
						pin_register[args.pin].PIN = new Pwm(pin_register[args.pin], pin_timer[pin_register[args.pin].TIM]);
						pin_register[args.pin].MOD = args.mode;
						break;
					//SERVO
					case 'servo':
						pin_register[args.pin].PIN = new Servo(pin_register[args.pin],pin_timer[pin_register[args.pin].TIM]);
						pin_register[args.pin].MOD = args.mode;
						break;
				}
			}
		});
	}
	catch(err){
		logger.error("BOARD PIN MODE ERROR - " + err.message);
		process.exit(1);
	}
}
Board.prototype.digitalWrite = function() {
    try {
		var args = Args([
					{ pin: 		Args.STRING 	| Args.Required },
					{ value:   	Args.INT 		| Args.Required },
					{ callback:	Args.FUNCTION 	| Args.Optional }
				], arguments);
	
		var check = checkDigitalWrite(args.pin);
		if(typeof(check) == 'error'){
			throw check;
		}
		else{
			if(args.value>1) args.value = 1;
			if(args.value<0) args.value = 0;
			
			if( typeof(args.callback) == 'function' ){
				pin_register[args.pin].PIN.write( args.value, function(val){
					args.callback(val);						
				});
			}
			else{
				pin_register[args.pin].PIN.writeSync(args.value);
				return args.value;
			}
			
		}
	}
	catch(err){
		logger.error("BOARD DIGITAL WRITE ERROR - " + err.message);
	}
}
Board.prototype.digitalRead = function(pin, callback) {
	try {
		var args = Args([
					{pin: 		Args.STRING | Args.Required },
					{callback:	Args.FUNCTION | Args.Optional}
				], arguments);
	
		var check = checkAnalogRead(args.pin);
		if(typeof(check) == 'error'){
			throw check;
		}
		else{
			if(typeof(args.callback) != 'undefined'){
				pin_register[args.pin].PIN.watch(function(err, val){
							if(err) { throw err; }
							else {args.callback(val);}
				});
			}
			else{
				return pin_register[args.pin].PIN.readSync();
			}
		}
	}
	catch(err){
		logger.error("BOARD DIGITAL READ ERROR - " + err.message);
	}  
}
Board.prototype.analogWrite = function() {
    try {
		var args = Args([
						{ pin: 		Args.STRING 	| Args.Required },
						{ value:   	Args.FLOAT 		| Args.Required },
						{ callback:	Args.FUNCTION 	| Args.Optional }
					], arguments);
			
			var check = checkAnalogWrite(args.pin);
			if(typeof(check) == 'error'){
				throw check;
			}
			else{

				if( typeof(args.callback) == 'function' ){
					pin_register[args.pin].PIN.write( args.value, function(val){
						args.callback(val);						
					});
				}
				else{
					pin_register[args.pin].PIN.writeSync(args.value);
					return args.value;
				}
			}
	}
	catch(err){
		logger.error("BOARD ANALOG WRITE ERROR - " + err.message);
	}
}
Board.prototype.analogRead = function() {
    try {		
		var args = Args([
							{pin: 		Args.STRING | Args.Required },
							{options:   Args.OBJECT | Args.Optional, _default : {} },
							{callback:	Args.FUNCTION | Args.Optional}
						], arguments);
		
		var check = checkAnalogRead(args.pin);
		if(typeof(check) == 'error'){
			throw check;
		}
		else{
			if(typeof(pin_register[args.pin].PIN) == 'undefined' || typeof(pin_register[args.pin].PIN) == {} ){
				var opts = clone(this.options); //faccio un clone delle opzioni generali ricavate nella connect
				utils.mergeRecursive(opts, args.options); 
				
				pin_register[args.pin].PIN = new Adc(pin_register[args.pin], opts);
			}
			if(typeof(args.callback) != 'undefined'){
				pin_register[args.pin].PIN.watch(function(err, val){
							if(err) { throw err; }
							else {args.callback(val);}
				});
			}
			else{
				return pin_register[args.pin].PIN.readSync();
			}
		}
	}
	catch(err){
		logger.error("BOARD ANALOG READ ERROR - " + err.message);
	}
}
Board.prototype.servoWrite = function(){
    try {
		var args = Args([
						{ pin: 		Args.STRING 	| Args.Required },
						{ angle:   	Args.INT 		| Args.Required },
						{ callback:	Args.FUNCTION 	| Args.Optional }
					], arguments);
					
		var check = checkServoWrite(args.pin);
		if(typeof(check) == 'error'){
			throw check;
		}
		else{
			if( typeof(args.callback) == 'function' ){
				pin_register[args.pin].PIN.write( args.angle, function(val){
					args.callback(angle);						
				});
			}
			else{
				pin_register[args.pin].PIN.writeSync(args.angle);
				return args.angle;
			}
		}
		
		
	}
	catch(err){
		logger.error("BOARD SERVO WRITE ERROR - " + err.message);
	}
}

/*** Virtual Board functions ***/
/* 
Board.prototype.virtualWrite = function(virtualpin, value){
	try {
		//checkVirtualWrite(pin,function(err){
		//TODO
		//});
				
	}
	catch(err){
		logger.error(err);
	}
}
Board.prototype.virtualRead = function(virtualpin, calback){
	try {
		//checkVirtualRead(pin,function(err){
		//TODO
		//});
	}
	catch(err){
		logger.error(err.message);
	} 
}
*/
/*** Check functions ***/
function checkPinMode(pinnumber, mode, callback){
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error(CHECK_MSG.PIN_UNDEFINED) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('d') && !pinnumber.toLowerCase().startsWith('p') && !pinnumber.toLowerCase().startsWith('s')){ 
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_DIGITAL,pinnumber)) );return false
		}
		if( !utils.contains(pin_layout.digital, pinnumber) && !utils.contains(pin_layout.pwm, pinnumber) && !utils.contains(pin_layout.servo, pinnumber)){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT,pinnumber)) );return false;
		}
		if( typeof(mode) == 'undefined'){
			callback(new Error(String.format(CHECK_MSG.MODE_UNDEFINED,pinnumber)) );return false;
		}
		if(	mode.toLowerCase() != utils.MODES.OUTPUT.toLowerCase()	&& 
			mode.toLowerCase() != utils.MODES.INPUT.toLowerCase() 	&&
			mode.toLowerCase() != utils.MODES.PWM.toLowerCase() 	&& 
			mode.toLowerCase() != utils.MODES.SERVO.toLowerCase()	){
			callback(new Error(String.format(CHECK_MSG.MODE_NOT_VALID, mode, pinnumber) + " Allowed modes are: "+ utils.MODES.OUTPUT +", "+ utils.MODES.INPUT + ", "+ utils.MODES.PWM + ", "+ utils.MODES.SERVO ));return false;
		}
		
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Pin Mode: '+ err.message) );
		return false
	}
}
function checkDigitalWrite(pinnumber){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			return new Error( CHECK_MSG.PIN_UNDEFINED );
		}
		if( !pinnumber.toLowerCase().startsWith('d')){ 
			return new Error( String.format(CHECK_MSG.PIN_NOT_DIGITAL, pinnumber) );
		}
		if(typeof(pin_register[pinnumber].MOD) == 'undefined'){
			return new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) );
		}
		if( !utils.contains(pin_layout.digital, pinnumber) ){
			return new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) );
		}
		if(pin_register[pinnumber].MOD.toLowerCase() != utils.MODES.OUTPUT.toLowerCase() ){
			return new Error( String.format(CHECK_MSG.MODE_NOT_VALID, pin_register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.OUTPUT);
		}		
		return true;
	}
	catch(err){
		return new Error('Check Digital Write: '+ err.message);
	}
}
function checkDigitalRead(pinnumber){
	try{
		if( typeof(pinnumber) == 'undefined'){
			return new Error( CHECK_MSG.PIN_UNDEFINED );
		}
		if( !pinnumber.toLowerCase().startsWith('d')){ 
			return new Error( String.format(CHECK_MSG.PIN_NOT_DIGITAL, pinnumber) );
		}
		if(typeof(pin_register[pinnumber].MOD) == 'undefined'){
			return new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) );
		}
		if( !utils.contains(pin_layout.digital, pinnumber) ){
			return new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) );
		}
		if(	pin_register[pinnumber].MOD.toLowerCase() != utils.MODES.OUTPUT.toLowerCase()	&& 
			pin_register[pinnumber].MOD.toLowerCase() != utils.MODES.INPUT.toLowerCase() 	&&
			pin_register[pinnumber].MOD.toLowerCase() != utils.MODES.PWM.toLowerCase() ){
			return new Error(String.format(CHECK_MSG.MODE_NOT_VALID, pin_register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.OUTPUT +", "+ utils.MODES.INPUT + ", "+ utils.MODES.PWM );
		}
		
		return true;
	}
	catch(err){
		return new Error('Check Digital Read: '+ err.message);
	}
}
function checkAnalogWrite(pinnumber){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			return new Error( CHECK_MSG.PIN_UNDEFINED ) 
		}
		if( !pinnumber.toLowerCase().startsWith('d') && !pinnumber.toLowerCase().startsWith('p')){ 
			return new Error( String.format(CHECK_MSG.PIN_NOT_DIGITAL, pinnumber) ) 
		}
		if(typeof(pin_register[pinnumber].MOD) == 'undefined'){
			return new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) 
		}
		/*if( !utils.contains(pin_layout.pwm, pinnumber) ){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) ) );return false;
		}
		if(pin_register[pinnumber].MOD.toLowerCase() != utils.MODES.PWM.toLowerCase() ){
			callback(new Error( String.format(CHECK_MSG.MODE_NOT_VALID, pin_register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.PWM));return false;
		}
		*/
		return true;
	}
	catch(err){
		return new Error('Check Analog Write: '+ err.message);
	}
}
function checkAnalogRead(pinnumber){
	try{
		if( typeof(pinnumber) == 'undefined'){
			return new Error( CHECK_MSG.PIN_UNDEFINED ) ;
		}
		if( !pinnumber.toLowerCase().startsWith('a') && !pinnumber.toLowerCase().startsWith('p')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_ANALOG, pinnumber ) ) );return false;
		}
		/* analog pin are in input mode (default), non verifico il pin mode
		if(typeof(pin_register[pin].MOD) == 'undefined'){
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) );return false;
		}
		*/
		if( !utils.contains(pin_layout.analog, pinnumber) && !utils.contains(pin_layout.pwm, pinnumber)){
			return new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) );
		}		
		return true;
	}
	catch(err){
		return new Error('Check Analog Read: '+ err.message);
	}
}
function checkServoWrite(pinnumber){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			return new Error( CHECK_MSG.PIN_UNDEFINED );
		}
		if( !pinnumber.toLowerCase().startsWith('d') &&  !pinnumber.toLowerCase().startsWith('p') && !pinnumber.toLowerCase().startsWith('s')){ 
			return new Error( String.format( CHECK_MSG.PIN_NOT_DIGITAL, pinnumber ) );
		}
		if(typeof(pin_register[pinnumber].MOD) == 'undefined'){
			return new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) );
		}
		if( !utils.contains(pin_layout.servo, pinnumber) ){
			return new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) );
		}
		if(pin_register[pinnumber].MOD.toLowerCase() != utils.MODES.SERVO.toLowerCase() ){
			return new Error( String.format(CHECK_MSG.MODE_NOT_VALID, pin_register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.SERVO);
		}
		return true;
	}
	catch(err){
		return new Error('Check Servo Write: '+ err.message);
	}
}
/*
function checkVirtualWrite(pinnumber, callback){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('v')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_VIRTUAL, pinnumber ) ) );return false;
		}
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Virtual Write: '+ err.message) );
		return false
	}
}
function checkVirtualRead(pinnumber, callback){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('v')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_VIRTUAL, pinnumber ) ) );return false;
		}
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Virtual Read: '+ err.message) );
		return false
	}
}
*/
