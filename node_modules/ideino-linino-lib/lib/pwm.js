/***
 * file: gpio.js
 * author: https://github.com/quasto
 * based on: https://github.com/fivdi/onoff/blob/master/onoff.js 
 ***/

var fs = require('fs'),
    pwmRootPath = '/sys/class/mcuio_pwm/',
	values = [];
	
var StringDecoder = require('string_decoder').StringDecoder;
var decoder = new StringDecoder('utf8');
	

for(i = 0; i < 256; i++){
	values.push(new Buffer(i.toString()))
}

	
exports.version = '0.0.1';

function Pwm(pwm, map, options) {
    var valuePath; // contiene il path al value della gpio
	
	options = options || {};
	
    this.pwm = pwm;
	this.map = map;
    this.pwmPath = pwmRootPath + this.map + '/';
    this.opts = {};
    this.opts.debounceTimeout = options.debounceTimeout || 0;
    this.sampling = options.sampling || 25;
	this.resolution = options.resolution || 40;
	this.readBuffer = new Buffer(3);
    this.listeners = [];
	
    valuePath = this.pwmPath + 'value';
	if (fs.readFileSync(this.pwmPath + 'enable') == '0' ){
        // The pin hasn't been exported yet so export it.
        fs.writeFileSync(this.pwmPath + 'enable', '1');

        // Allow all users to read and write the GPIO value file
        fs.chmodSync(valuePath, 0666);
    } 
	
    this.valueFd = fs.openSync(valuePath, 'r+'); // Cache fd for performance.

}

exports.Pwm = Pwm;

Pwm.prototype.watch = function(callback) {
    var events;
	this.listeners.push(callback);
	var that = this;
	var old_value, new_value;
	if(this.listeners.length == 1 ){
		new_value = that.readSync();
		old_value = new_value;
		var timer = setInterval(function(){
				callbacks = that.listeners.slice(0);
				if(callbacks.length > 0){
					new_value = that.readSync();
					if( new_value <= (old_value - that.resolution) || //risoluzione dell'informazione
						new_value >= (old_value + that.resolution) ){
						old_value = new_value;
						callbacks.forEach(function (callback) {
							callback(null, new_value);
						});
					}
				}
		},this.sampling);//periodo di campionamento
	}
};

/**
 * Write PWM value synchronously.
 *
 * value: number // from 0 to 255
 */
Pwm.prototype.writeSync = function(value) {
    var writeBuffer = values[value];//new Buffer(value);
	fs.writeSync(this.valueFd, writeBuffer, 0, writeBuffer.length, 0);
};

//TODO: write async


/**
 * Read PWM value synchronously.
 *
 * Returns - number // from 0 to 255
 */
Pwm.prototype.readSync = function() {
    this.readBuffer.fill(0);//pulisco il buffer
	fs.readSync(this.valueFd, this.readBuffer, 0, 3, 0);
    //return this.readBuffer[0] === one[0] ? 1 : 0;
	return parseInt(decoder.write(this.readBuffer));
};

//TODO: read async


/**
 * Get PWM options.
 *
 * Returns - object // Must not be modified
 */
Pwm.prototype.options = function() {
    return this.opts;
};

/**
 * Reverse the effect of exporting the PWM to userspace. The Adc object
 * should not be used after calling this method.
 */
/*
Pwm.prototype.unexport = function(callback) {
    this.unwatchAll();
    fs.closeSync(this.valueFd);
    fs.writeFileSync(adcEnablingPath + 'enable', '0');
};
*/
/*
Pwm.prototype.isExported = function(){
	return fs.existsSync(this.adcPath);
}
*/